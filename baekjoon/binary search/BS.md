# Binary Search&Parametric Search

**Binary Search과 이를 응용한 Parametric Search는 정답이 항상 존재하며, 조건에 따른 값의 변화가 단조롭게 변화할 때 위 알고리즘을 사용하여 정답을 O(logN) 내에 찾을 수 있다.<br/>중요한 것은 parametric search에서 포함, 미포함을 헷갈리지 않고 엣지 케이스가 발생하지 않도록 탐색을 구현해야 하며, 초기 low 값과 high 값을 설정할 때 예외 없이 모든 범위가 탐색될 수 있도록 잘 짜야 한다. 탐색을 구현하기 위한 여러 방법이 있지만 아래와 같은 방법을 자주 사용하였다.**
```cpp
int lo,hi;
while(lo<=hi){
    int mid=(lo+hi)/2;
    /*
    code...
    */

   //if를 만족하면 오른쪽에서 탐색, 만족하지 않으면 왼쪽에서 탐색
    if(*statement)
        lo=mid+1;
    else
        hi=mid-1;   
}
//lo가 hi보다 커질때 종료되므로, 조건에 맞춰 원하는 값을 hi,lo 중 선택
//마지막에 탐색 범위를 선택하는 과정에서,
```
**위 코드에서 탈출 조건을 lo<=hi로 잡았다면, mid를 포함하지 않은 영역에서 탐색을 진행해야 무한루프에 빠지지 않는다. "어떤 조건을 만족하는 최소 혹은 최댓값" 이 아닌, 이를 만족하는 값이 단 하나 존재한다면, mid가 정답 조건과 일치해질 때 탈출하는 조건으로 탐색을 수행해도 된다.<br/><br/>이를 활용한 문제는 매개변수 탐색, 이분 탐색을 이용하는 문제라는 것을 알아내는 것이 가장 어려운 부분이다. 즉**<br/>
<ul>정답이 반드시 존재하고, 테스트 케이스의 수가 매우 많으며 우리가 탐색하려는 값을 늘이거나 줄였을 때의 정답과의 오차의 경향성이 단조롭다면</ul>

**정답을 이분 탐색을 통해서 찾을 수 있을 것이라는 발상을 해 보아야 한다. 이를 보여주는 가장 대표적인 예시인 백준의 "나무 자르기" 문제를 확인해 보면 어느정도 감이 올 것이다.**

## 다시 풀어볼 문제

- 1300 K번째 수 ★★★ 간단한 문제로 보일 수 있지만, N이 10^5 크기라 시간 초과가 나기 매우 쉽다. 따라서 답이 존재할 것이라고 생각하고 적절한 조건을 통해 이분 탐색을 진행해야 하는데, 이 조건을 도출해 내는 과정을 다시 한번 생각해 보자.
- 2110 공유기 설치 ★★ 얼핏 보면 그리디 알고리즘 문제라고 생각하기 쉽다. 하지만 그리디로 풀 시(내가 모르는 것일수도 있지만) 집의 개수가 매우 많기 떄문에 시간 초과가 나기 쉽다. 테스트 케이스들을 감안해 O(NlogN)안에 문제를 풀어야 하는데, 이를 만족할 수 있는 방법은 이분 탐색이다. 역시 이분 탐색을 할 때 수행해야하는 코드를 생각해내기 어려운 편이므로, 다시 풀어보도록 하자.
- 2343 기타 레슨 ★★ 전형적인 이분 탐색 문제, 그리디나 dp를 사용하는 것보다 훨씬 빠른 시간 안에 쉽게 답을 찾아낼 수 있다.
- 2805 나무 자르기 ★ 전형적인 이분 탐색 문제의 대표적인 예시, 이 알고리즘이 적용되는 예시를 보기 위해서는 이 예제를 다시한번 보자.
- 6236 용돈 관리 ★★ 해석이 어려워 애먹은 문제이다. 최솟값 설정에 주의해야 하는데, 하루에 사용하는 최대 액수보다 작다면, 문제에서 "하루에 한번만 인출" 할수 있다고 했기 때문에 새로 인출하여도 그 날을 보낼 수 없게 된다. 범위 설정에 유의하도록 하자.