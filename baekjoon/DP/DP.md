# DP

**DP(Dynamic Programming)은 문제가 최적 부분 구조(Optimal Substructure)을 만족시킬 때 풀이 알고리즘으로 사용할 수 있다.<br/>최적 부분 구조란, 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법인 것을 의미하는데 DP의 풀이법은 분할 정복, 그리디와 유사하면서도 다르다.<br/>우선, DP에서는 분할 정복과 달리 이전 문제의 해를 재사용하는 경우가 자주 있다. 대표적인 예시가 DP를 이용한 피보나치 수열 문제이다. 분할 정복에서는 나눈 문제들끼리의 연관성이 없어, 분할해 각각 작은 문제를 해결하고 답을 모으면 되지만, DP에서는 작은 문제의 해가 다음 작은 문제의 문제 풀이에 또다시 이용되는 경우가 잦다. 이래서 별도의 dp컨테이너를 사용하여 메모이제이션을 사용하여 연산 수를 줄이는 기법을 사용한다.<br/> 다음으로, 그리디와의 차이는 다음 문제의 차이를 통해 설명할 수 있다.<br/>그리디 알고리즘에서 사용하는 동전 문제는, 한 동전이 다른 동전의 배수이다. 즉 큰 금액의 동전을 작은 금액의 동전을 통해 구성할 수 있다. <br/>반면 DP에서는 이런 가정이 성립하지 않아도, 메모이제이션을 통해 모든 경우를 탐색할 수 있다. 따라서 큰 금액의 동전이 작은 금액의 동전의 배수가 될 필요가 없다.<br/><br/>문제 풀이의 핵심은 dp[i]의 경우, i이전의 경우들은 전부 고려가 된 값이기 때문에 앞의 것을 고려할 필요가 없다는 것이며 이를 사용하여 러닝타임을 줄여서 문제를 해결할 수 있다.**

## 다시 풀어볼 문제

- 1149 RGB거리 ★★★ dp 점화식을 세울 때, 바로 앞 dp배열에서의 최솟값만 고려하면 된다. 이미 dp배열에는 이전 단계의 최솟값이 들어있기 때문이다.
- 1463 1로 만들기 ★★ dp[i]는 i의 수를 1로 만드는 최소 횟수로 설정하자
- 1904 01타일 ★
- 1912 연속합 ★★ 연속합이 언제 끊기는지를 기준으로, dp배열에는 최대 연속합이 들어가도록 설계
- 2293 동전1 ★★★★ dp배열의 점화식을 손으로 쓰면서 파악해 보자
- 2294 동전2 ★★★ 최솟값의 갱신
- 9251 LCS ★★★★ dp를 어떻게 구성할지 그리면서 생각해 보자. s1[i], s2[j]까지의 문자를 고려했을 때 LCS는 그 이전 문자까지의 LCS로부터 유도해 낼 수 있다.
- 9456 스티커 ★★
- 11052 카드 구매하기 ★★★★ 완전탐색을 어떤 방법으로 할지, dp 컨테이너에 어떤 값을 담아야 할지를 잘 생각해 보자
- 11053 가장 긴 증가하는 부분수열 ★★★★
- 12865 평범한 배낭 ★★★★ 0-1 knapsack problem
- 16500 문자열 비교 ★★★ 무엇을 기준으로 놓고 무엇을 비교할지를 잘 고민해보고, "공백이 없이 단어를 형성"에 집중하여 dp에 어떤 값을 넣을지를 고민해 보자
